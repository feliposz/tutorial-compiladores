
=================
Testes de Sucesso
=================


TEST: cap01-craddle  0<nul 

TEST: echo 0  | cap02-expr
	MOV AX, 0

TEST: echo -1  | cap02-expr
	XOR AX, AX
	PUSH AX
	MOV AX, 1
	POP BX
	SUB AX, BX
	NEG AX

TEST: echo 2+3  | cap02-expr
	MOV AX, 2
	PUSH AX
	MOV AX, 3
	POP BX
	ADD AX, BX

TEST: echo 4-5  | cap02-expr
	MOV AX, 4
	PUSH AX
	MOV AX, 5
	POP BX
	SUB AX, BX
	NEG AX

TEST: echo 6*7  | cap02-expr
	MOV AX, 6
	PUSH AX
	MOV AX, 7
	POP BX
	IMUL BX

TEST: echo 8/9  | cap02-expr
	MOV AX, 8
	PUSH AX
	MOV AX, 9
	POP BX
	XCHG AX, BX
	CWD
	IDIV BX

TEST: echo 2+3*4  | cap02-expr
	MOV AX, 2
	PUSH AX
	MOV AX, 3
	PUSH AX
	MOV AX, 4
	POP BX
	IMUL BX
	POP BX
	ADD AX, BX

TEST: echo 1+2-3*4/5  | cap02-expr
	MOV AX, 1
	PUSH AX
	MOV AX, 2
	POP BX
	ADD AX, BX
	PUSH AX
	MOV AX, 3
	PUSH AX
	MOV AX, 4
	POP BX
	IMUL BX
	PUSH AX
	MOV AX, 5
	POP BX
	XCHG AX, BX
	CWD
	IDIV BX
	POP BX
	SUB AX, BX
	NEG AX

TEST: echo 2*(3+4)  | cap02-expr
	MOV AX, 2
	PUSH AX
	MOV AX, 3
	PUSH AX
	MOV AX, 4
	POP BX
	ADD AX, BX
	POP BX
	IMUL BX

TEST: echo 1+(2-(3+(4-5)))  | cap02-expr
	MOV AX, 1
	PUSH AX
	MOV AX, 2
	PUSH AX
	MOV AX, 3
	PUSH AX
	MOV AX, 4
	PUSH AX
	MOV AX, 5
	POP BX
	SUB AX, BX
	NEG AX
	POP BX
	ADD AX, BX
	POP BX
	SUB AX, BX
	NEG AX
	POP BX
	ADD AX, BX

TEST: echo (1+2)/((3+4)+(5-6))  | cap02-expr
	MOV AX, 1
	PUSH AX
	MOV AX, 2
	POP BX
	ADD AX, BX
	PUSH AX
	MOV AX, 3
	PUSH AX
	MOV AX, 4
	POP BX
	ADD AX, BX
	PUSH AX
	MOV AX, 5
	PUSH AX
	MOV AX, 6
	POP BX
	SUB AX, BX
	NEG AX
	POP BX
	ADD AX, BX
	POP BX
	XCHG AX, BX
	CWD
	IDIV BX

TEST: echo -(3-2)  | cap02-expr
	XOR AX, AX
	PUSH AX
	MOV AX, 3
	PUSH AX
	MOV AX, 2
	POP BX
	SUB AX, BX
	NEG AX
	POP BX
	SUB AX, BX
	NEG AX

TEST: echo d=b*b-4*a*c  | cap03-single
	MOV AX, [B]
	PUSH AX
	MOV AX, [B]
	POP BX
	IMUL BX
	PUSH AX
	MOV AX, 4
	PUSH AX
	MOV AX, [A]
	POP BX
	IMUL BX
	PUSH AX
	MOV AX, [C]
	POP BX
	IMUL BX
	POP BX
	SUB AX, BX
	NEG AX
	MOV [D], AX

TEST: echo x=f()+g()  | cap03-single
	CALL F
	PUSH AX
	CALL G
	POP BX
	ADD AX, BX
	MOV [X], AX

TEST: echo nota=(prova1+prova2*2)/3  | cap03-multi
	MOV AX, [PROVA1]
	PUSH AX
	MOV AX, [PROVA2]
	PUSH AX
	MOV AX, 2
	POP BX
	IMUL BX
	POP BX
	ADD AX, BX
	PUSH AX
	MOV AX, 3
	POP BX
	XCHG AX, BX
	CWD
	IDIV BX
	MOV [NOTA], AX

TEST: echo nota = (prova1 + prova2 * 2) / 3  | cap03-multi
	MOV AX, [PROVA1]
	PUSH AX
	MOV AX, [PROVA2]
	PUSH AX
	MOV AX, 2
	POP BX
	IMUL BX
	POP BX
	ADD AX, BX
	PUSH AX
	MOV AX, 3
	POP BX
	XCHG AX, BX
	CWD
	IDIV BX
	MOV [NOTA], AX

TEST: echo x = 2 * y + 3  | cap03-multi
	MOV AX, 2
	PUSH AX
	MOV AX, [Y]
	POP BX
	IMUL BX
	PUSH AX
	MOV AX, 3
	POP BX
	ADD AX, BX
	MOV [X], AX

TEST: echo x = x + 3 - 2 - (5 - 4)  | cap03-multi
	MOV AX, [X]
	PUSH AX
	MOV AX, 3
	POP BX
	ADD AX, BX
	PUSH AX
	MOV AX, 2
	POP BX
	SUB AX, BX
	NEG AX
	PUSH AX
	MOV AX, 5
	PUSH AX
	MOV AX, 4
	POP BX
	SUB AX, BX
	NEG AX
	POP BX
	SUB AX, BX
	NEG AX
	MOV [X], AX

TEST: echo delta  =  (b * b  )  -(  4*a*c   )  | cap03-multi
	MOV AX, [B]
	PUSH AX
	MOV AX, [B]
	POP BX
	IMUL BX
	PUSH AX
	MOV AX, 4
	PUSH AX
	MOV AX, [A]
	POP BX
	IMUL BX
	PUSH AX
	MOV AX, [C]
	POP BX
	IMUL BX
	POP BX
	SUB AX, BX
	NEG AX
	MOV [DELTA], AX

TEST: echo resultado = funcao () + outra(  )  | cap03-multi
	CALL FUNCAO
	PUSH AX
	CALL OUTRA
	POP BX
	ADD AX, BX
	MOV [RESULTADO], AX

TEST: echo a=1b=2c=3d=b*b-4*a*c!d.  | cap04-interp
D -> -8

TEST: echo iee  | cap05-control
	; condition
	JZ L0
L0:
	; END

TEST: echo AiBeCe  | cap05-control
	; A
	; condition
	JZ L0
	; B
L0:
	; C
	; END

TEST: echo AiBiCeDeFe  | cap05-control
	; A
	; condition
	JZ L0
	; B
	; condition
	JZ L1
	; C
L1:
	; D
L0:
	; F
	; END

TEST: echo AiBlCeDe  | cap05-control
	; A
	; condition
	JZ L0
	; B
	JMP L1
L0:
	; C
L1:
	; D
	; END

TEST: echo wXee  | cap05-control
L0:
	; condition
	JZ L1
	; X
	JMP L0
L1:
	; END

TEST: echo pXee  | cap05-control
L0:
	; X
	JMP L0
L1:
	; END

TEST: echo rXue  | cap05-control
L0:
	; X
	; condition
	JZ L0
L1:
	; END

TEST: echo fI=ee  | cap05-control
	; expression
	DEC AX
	MOV [I], AX
	; expression
	PUSH AX
L0:
	MOV AX, [I]
	INC AX
	MOV [I], AX
	POP BX
	PUSH BX
	CMP AX, BX
	JG L1
	JMP L0
L1:
	POP AX
	; END

TEST: echo AfI=BeCe  | cap05-control
	; A
	; expression
	DEC AX
	MOV [I], AX
	; expression
	PUSH AX
L0:
	MOV AX, [I]
	INC AX
	MOV [I], AX
	POP BX
	PUSH BX
	CMP AX, BX
	JG L1
	; B
	JMP L0
L1:
	POP AX
	; C
	; END

TEST: echo dee  | cap05-control
	; expression
	MOV CX, AX
L0:
	PUSH CX
	POP CX
	LOOP L0
	PUSH CX
L1:
	POP CX
	; END

TEST: echo pABCbDEFee  | cap05-control
L0:
	; A
	; B
	; C
	JMP L1
	; D
	; E
	; F
	JMP L0
L1:
	; END

TEST: echo pwXepYbZeiAlberCfI=Deuee  | cap05-control
L0:
L2:
	; condition
	JZ L3
	; X
	JMP L2
L3:
L4:
	; Y
	JMP L5
	; Z
	JMP L4
L5:
	; condition
	JZ L6
	; A
	JMP L7
L6:
	JMP L1
L7:
L8:
	; C
	; expression
	DEC AX
	MOV [I], AX
	; expression
	PUSH AX
L10:
	MOV AX, [I]
	INC AX
	MOV [I], AX
	POP BX
	PUSH BX
	CMP AX, BX
	JG L11
	; D
	JMP L10
L11:
	POP AX
	; condition
	JZ L8
L9:
	JMP L0
L1:
	; END

TEST: echo a*(-b)  | cap06-bool1
	MOV AX, [A]
	PUSH AX
	MOV AX, [B]
	NEG AX
	POP BX
	IMUL BX

TEST: echo a-(-b)  | cap06-bool1
	MOV AX, [A]
	PUSH AX
	MOV AX, [B]
	NEG AX
	POP BX
	SUB AX, BX
	NEG AX

TEST: echo a^&!b  | cap06-bool1
	MOV AX, [A]
	PUSH AX
	MOV AX, [B]
	NOT AX
	POP BX
	AND AX, BX

TEST: echo T  | cap06-bool1
	MOV AX, -1

TEST: echo F  | cap06-bool1
	MOV AX, 0

TEST: echo !T  | cap06-bool1
	MOV AX, -1
	NOT AX

TEST: echo T^&F  | cap06-bool1
	MOV AX, -1
	PUSH AX
	MOV AX, 0
	POP BX
	AND AX, BX

TEST: echo T^|F  | cap06-bool1
	MOV AX, -1
	PUSH AX
	MOV AX, 0
	POP BX
	OR AX, BX

TEST: echo T^~F  | cap06-bool1
	MOV AX, -1
	PUSH AX
	MOV AX, 0
	POP BX
	XOR AX, BX

TEST: echo 1^>2  | cap06-bool1
	MOV AX, 1
	PUSH AX
	MOV AX, 2
	POP BX
	CMP BX, AX
	JG L0
	MOV AX, 0
	JMP L1
L0:
	MOV AX, -1
L1:

TEST: echo 3^<4  | cap06-bool1
	MOV AX, 3
	PUSH AX
	MOV AX, 4
	POP BX
	CMP BX, AX
	JL L0
	MOV AX, 0
	JMP L1
L0:
	MOV AX, -1
L1:

TEST: echo 5=6  | cap06-bool1
	MOV AX, 5
	PUSH AX
	MOV AX, 6
	POP BX
	CMP BX, AX
	JE L0
	MOV AX, 0
	JMP L1
L0:
	MOV AX, -1
L1:

TEST: echo 5#6  | cap06-bool1
	MOV AX, 5
	PUSH AX
	MOV AX, 6
	POP BX
	CMP BX, AX
	JNE L0
	MOV AX, 0
	JMP L1
L0:
	MOV AX, -1
L1:

TEST: echo x()  | cap06-bool1
	CALL X

TEST: echo ((x()+1)^>(5*y()))^|(a#b^&c^<d)  | cap06-bool1
	CALL X
	PUSH AX
	MOV AX, 1
	POP BX
	ADD AX, BX
	PUSH AX
	MOV AX, 5
	PUSH AX
	CALL Y
	POP BX
	IMUL BX
	POP BX
	CMP BX, AX
	JG L0
	MOV AX, 0
	JMP L1
L0:
	MOV AX, -1
L1:
	PUSH AX
	MOV AX, [A]
	PUSH AX
	MOV AX, [B]
	POP BX
	CMP BX, AX
	JNE L2
	MOV AX, 0
	JMP L3
L2:
	MOV AX, -1
L3:
	PUSH AX
	MOV AX, [C]
	PUSH AX
	MOV AX, [D]
	POP BX
	CMP BX, AX
	JL L4
	MOV AX, 0
	JMP L5
L4:
	MOV AX, -1
L5:
	POP BX
	AND AX, BX
	POP BX
	OR AX, BX

TEST: echo iA=BX=1lX=2ee  | cap06-bool2
	MOV AX, [A]
	PUSH AX
	MOV AX, [B]
	POP BX
	CMP BX, AX
	JE L0
	MOV AX, 0
	JMP L1
L0:
	MOV AX, -1
L1:
	JZ L2
	MOV AX, 1
	MOV [X], AX
	JMP L3
L2:
	MOV AX, 2
	MOV [X], AX
L3:
	; END

TEST: echo X=1fA=1t9Y=2eZ=3e  | cap06-bool2
	MOV AX, 1
	MOV [X], AX
	MOV AX, 1
	DEC AX
	MOV [A], AX
	MOV AX, 9
	PUSH AX
L0:
	MOV AX, [A]
	INC AX
	MOV [A], AX
	POP BX
	PUSH BX
	CMP AX, BX
	JG L1
	MOV AX, 2
	MOV [Y], AX
	JMP L0
L1:
	POP AX
	MOV AX, 3
	MOV [Z], AX
	; END

TEST: echo 1 23 456 a bc def = # . : ; ! ? + - * / if else endif end  | cap07-lex-enum
Number: 1
Number: 23
Number: 456
Ident: A
Ident: BC
Ident: DEF
Operator: =
Operator: #
Operator: .
Operator: :
Operator: ;
Operator: !
Operator: ?
Operator: +
Operator: -
Operator: *
Operator: /
Keyword: IF
Keyword: ELSE
Keyword: ENDIF
Keyword: END

TEST: echo 1 23 456 a bc def = # . : ; ! ? + - * / if else endif end  | cap07-lex-char
Number: 1
Number: 23
Number: 456
Ident: A
Ident: BC
Ident: DEF
Operator: =
Operator: #
Operator: .
Operator: :
Operator: ;
Operator: !
Operator: ?
Operator: +
Operator: -
Operator: *
Operator: /
Keyword: IF
Keyword: ELSE
Keyword: ENDIF
Keyword: END

TEST: echo ia=1lb=2ee   | cap07-subset
	; condition
	JZ L0
	MOV AX, 1
	MOV [A], AX
	JMP L1
L0:
	MOV AX, 2
	MOV [B], AX
L1:
	; END

TEST: echo if a = 1 else b = 2 endif end   | cap07-lex-subset
	; condition
	JZ L0
	MOV AX, 1
	MOV [A], AX
	JMP L1
L0:
	MOV AX, 2
	MOV [B], AX
L1:
	; END

TEST: echo pXbe.  | cap09-top-pascal
	.model small
	.stack
	.code
PROG segment byte public
	assume cs:PROG,ds:PROG,es:PROG,ss:PROG
X:
exit_prog:
	MOV AX, 4C00h  ; AH=4C (termina execucao do programa) AL=00 (saida ok)
	INT 21h       ; chamada de sistema DOS
PROG ends
	end X

TEST: echo pXlcltcvtpvfvlbXYZe.  | cap09-top-pascal
	.model small
	.stack
	.code
PROG segment byte public
	assume cs:PROG,ds:PROG,es:PROG,ss:PROG
X:
exit_prog:
	MOV AX, 4C00h  ; AH=4C (termina execucao do programa) AL=00 (saida ok)
	INT 21h       ; chamada de sistema DOS
PROG ends
	end X

TEST: echo,  | cap09-top-c

TEST: echo iI,J;g(){}uU;iS;f(){}cC,D;  | cap09-top-c
Class: a, Sign: s, Type: i, Data: I
Class: a, Sign: s, Type: i, Data: J
Class: a, Sign: s, Type: i, Function: G
Class: a, Sign: u, Type: i, Data: U
Class: a, Sign: s, Type: i, Data: S
Class: a, Sign: s, Type: i, Function: F
Class: a, Sign: s, Type: c, Data: C
Class: a, Sign: s, Type: c, Data: D

TEST: echo auiX,Y;xiZ;  | cap09-top-c
Class: a, Sign: u, Type: i, Data: X
Class: a, Sign: u, Type: i, Data: Y
Class: x, Sign: s, Type: i, Data: Z

TEST: echo pbe.  | cap10-tiny01
	.model small
	.stack
	.code
PROG segment byte public
	assume cs:PROG,ds:PROG,es:PROG,ss:PROG
MAIN:
	MOV AX, PROG
	MOV DS, AX
	MOV ES, AX
	MOV AX, 4C00h
	INT 21h
PROG ends
	end MAIN

TEST: echo pvXvYvZbe.  | cap10-tiny01
	.model small
	.stack
	.code
PROG segment byte public
	assume cs:PROG,ds:PROG,es:PROG,ss:PROG
X:	dw 0
Y:	dw 0
Z:	dw 0
MAIN:
	MOV AX, PROG
	MOV DS, AX
	MOV ES, AX
	MOV AX, 4C00h
	INT 21h
PROG ends
	end MAIN

TEST: echo pvX,Y,ZvM,NvObe.  | cap10-tiny01
	.model small
	.stack
	.code
PROG segment byte public
	assume cs:PROG,ds:PROG,es:PROG,ss:PROG
X:	dw 0
Y:	dw 0
Z:	dw 0
M:	dw 0
N:	dw 0
O:	dw 0
MAIN:
	MOV AX, PROG
	MOV DS, AX
	MOV ES, AX
	MOV AX, 4C00h
	INT 21h
PROG ends
	end MAIN

TEST: echo pvX=1,Y=2,Z=3vM,NvO=9be.  | cap10-tiny01
	.model small
	.stack
	.code
PROG segment byte public
	assume cs:PROG,ds:PROG,es:PROG,ss:PROG
X:	dw 1
Y:	dw 2
Z:	dw 3
M:	dw 0
N:	dw 0
O:	dw 9
MAIN:
	MOV AX, PROG
	MOV DS, AX
	MOV ES, AX
	MOV AX, 4C00h
	INT 21h
PROG ends
	end MAIN

TEST: echo pvX=-1,Y=23,Z=456vM,NvO=-7890be.  | cap10-tiny01
	.model small
	.stack
	.code
PROG segment byte public
	assume cs:PROG,ds:PROG,es:PROG,ss:PROG
X:	dw -1
Y:	dw 23
Z:	dw 456
M:	dw 0
N:	dw 0
O:	dw -7890
MAIN:
	MOV AX, PROG
	MOV DS, AX
	MOV ES, AX
	MOV AX, 4C00h
	INT 21h
PROG ends
	end MAIN

TEST: echo pbXYZe.  | cap10-tiny01
	.model small
	.stack
	.code
PROG segment byte public
	assume cs:PROG,ds:PROG,es:PROG,ss:PROG
MAIN:
	MOV AX, PROG
	MOV DS, AX
	MOV ES, AX
Error: '=' expected!

TEST: echo pvX=1,Y=2,ZbZ=X-Y+(-X*Y)/10e.  | cap10-tiny01
	.model small
	.stack
	.code
PROG segment byte public
	assume cs:PROG,ds:PROG,es:PROG,ss:PROG
X:	dw 1
Y:	dw 2
Z:	dw 0
MAIN:
	MOV AX, PROG
	MOV DS, AX
	MOV ES, AX
	MOV AX, WORD PTR X
	PUSH AX
	MOV AX, WORD PTR Y
	POP BX
	SUB AX, BX
	NEG AX
	PUSH AX
	MOV AX, WORD PTR X
	NEG AX
	PUSH AX
	MOV AX, WORD PTR Y
	POP BX
	IMUL BX
	PUSH AX
	MOV AX, 10
	POP BX
	XCHG AX, BX
	CWD
	IDIV BX
	POP BX
	ADD AX, BX
	MOV WORD PTR Z, AX
	MOV AX, 4C00h
	INT 21h
PROG ends
	end MAIN

TEST: echo pvX,Y,ZbX=Z^>Ye.  | cap10-tiny01
	.model small
	.stack
	.code
PROG segment byte public
	assume cs:PROG,ds:PROG,es:PROG,ss:PROG
X:	dw 0
Y:	dw 0
Z:	dw 0
MAIN:
	MOV AX, PROG
	MOV DS, AX
	MOV ES, AX
	MOV AX, WORD PTR Z
	PUSH AX
	MOV AX, WORD PTR Y
	POP BX
	CMP BX, AX
	JG L0
	XOR AX, AX
	JMP L1
L0:
	MOV AX, -1
L1:
	MOV WORD PTR X, AX
	MOV AX, 4C00h
	INT 21h
PROG ends
	end MAIN

TEST: echo pvXbX=0wX^<9X=X+1ee.  | cap10-tiny01
	.model small
	.stack
	.code
PROG segment byte public
	assume cs:PROG,ds:PROG,es:PROG,ss:PROG
X:	dw 0
MAIN:
	MOV AX, PROG
	MOV DS, AX
	MOV ES, AX
	MOV AX, 0
	MOV WORD PTR X, AX
L0:
	MOV AX, WORD PTR X
	PUSH AX
	MOV AX, 9
	POP BX
	CMP BX, AX
	JL L2
	XOR AX, AX
	JMP L3
L2:
	MOV AX, -1
L3:
	JZ L1
	MOV AX, WORD PTR X
	PUSH AX
	MOV AX, 1
	POP BX
	ADD AX, BX
	MOV WORD PTR X, AX
	JMP L0
L1:
	MOV AX, 4C00h
	INT 21h
PROG ends
	end MAIN

TEST: echo pvX,YbX=1iX=1Y=Y-1lY=Y+2ee.  | cap10-tiny01
	.model small
	.stack
	.code
PROG segment byte public
	assume cs:PROG,ds:PROG,es:PROG,ss:PROG
X:	dw 0
Y:	dw 0
MAIN:
	MOV AX, PROG
	MOV DS, AX
	MOV ES, AX
	MOV AX, 1
	MOV WORD PTR X, AX
	MOV AX, WORD PTR X
	PUSH AX
	MOV AX, 1
	POP BX
	CMP BX, AX
	JE L0
	XOR AX, AX
	JMP L1
L0:
	MOV AX, -1
L1:
	JZ L2
	MOV AX, WORD PTR Y
	PUSH AX
	MOV AX, 1
	POP BX
	SUB AX, BX
	NEG AX
	MOV WORD PTR Y, AX
	JMP L3
L2:
	MOV AX, WORD PTR Y
	PUSH AX
	MOV AX, 2
	POP BX
	ADD AX, BX
	MOV WORD PTR Y, AX
L3:
	MOV AX, 4C00h
	INT 21h
PROG ends
	end MAIN

TEST: echo Program Begin End .  | cap10-tiny10
	.model small
	.stack
	.code
extrn READ:near, WRITE:near
PROG segment byte public
	assume cs:PROG,ds:PROG,es:PROG,ss:PROG
MAIN:
	MOV AX, PROG
	MOV DS, AX
	MOV ES, AX
	MOV AX, 4C00h
	INT 21h
PROG ends
	end MAIN

TEST: echo Program Var x Var y Var z Begin End .  | cap10-tiny10
	.model small
	.stack
	.code
extrn READ:near, WRITE:near
PROG segment byte public
	assume cs:PROG,ds:PROG,es:PROG,ss:PROG
X:	dw 0
Y:	dw 0
Z:	dw 0
MAIN:
	MOV AX, PROG
	MOV DS, AX
	MOV ES, AX
	MOV AX, 4C00h
	INT 21h
PROG ends
	end MAIN

TEST: echo Program Var x,Y,z Var M , N Var O Begin End .  | cap10-tiny10
	.model small
	.stack
	.code
extrn READ:near, WRITE:near
PROG segment byte public
	assume cs:PROG,ds:PROG,es:PROG,ss:PROG
X:	dw 0
Y:	dw 0
Z:	dw 0
M:	dw 0
N:	dw 0
O:	dw 0
MAIN:
	MOV AX, PROG
	MOV DS, AX
	MOV ES, AX
	MOV AX, 4C00h
	INT 21h
PROG ends
	end MAIN

TEST: echo Program Var x = 1 , y = 2 , z = 3 Var M , N Var O = 9 Begin End .  | cap10-tiny10
	.model small
	.stack
	.code
extrn READ:near, WRITE:near
PROG segment byte public
	assume cs:PROG,ds:PROG,es:PROG,ss:PROG
X:	dw 1
Y:	dw 2
Z:	dw 3
M:	dw 0
N:	dw 0
O:	dw 9
MAIN:
	MOV AX, PROG
	MOV DS, AX
	MOV ES, AX
	MOV AX, 4C00h
	INT 21h
PROG ends
	end MAIN

TEST: echo Program Var x = - 1 , y = 23 , z = 456 Var M , N Var O = - 7890 Begin End .  | cap10-tiny10
	.model small
	.stack
	.code
extrn READ:near, WRITE:near
PROG segment byte public
	assume cs:PROG,ds:PROG,es:PROG,ss:PROG
X:	dw -1
Y:	dw 23
Z:	dw 456
M:	dw 0
N:	dw 0
O:	dw -7890
MAIN:
	MOV AX, PROG
	MOV DS, AX
	MOV ES, AX
	MOV AX, 4C00h
	INT 21h
PROG ends
	end MAIN

TEST: echo Program Var x = 1 , y = 2 , z Begin z = x - y + ( - x * y ) / 10 End .  | cap10-tiny10
	.model small
	.stack
	.code
extrn READ:near, WRITE:near
PROG segment byte public
	assume cs:PROG,ds:PROG,es:PROG,ss:PROG
X:	dw 1
Y:	dw 2
Z:	dw 0
MAIN:
	MOV AX, PROG
	MOV DS, AX
	MOV ES, AX
	MOV AX, WORD PTR X
	PUSH AX
	MOV AX, WORD PTR Y
	POP BX
	SUB AX, BX
	NEG AX
	PUSH AX
	MOV AX, WORD PTR X
	NEG AX
	PUSH AX
	MOV AX, WORD PTR Y
	POP BX
	IMUL BX
	PUSH AX
	MOV AX, 10
	POP BX
	XCHG AX, BX
	CWD
	IDIV BX
	POP BX
	ADD AX, BX
	MOV WORD PTR Z, AX
	MOV AX, 4C00h
	INT 21h
PROG ends
	end MAIN

TEST: echo Program Var x , y , z Begin x = z ^>= y End .  | cap10-tiny10
	.model small
	.stack
	.code
extrn READ:near, WRITE:near
PROG segment byte public
	assume cs:PROG,ds:PROG,es:PROG,ss:PROG
X:	dw 0
Y:	dw 0
Z:	dw 0
MAIN:
	MOV AX, PROG
	MOV DS, AX
	MOV ES, AX
	MOV AX, WORD PTR Z
	PUSH AX
	MOV AX, WORD PTR Y
	POP BX
	CMP BX, AX
	JGE L0
	XOR AX, AX
	JMP L1
L0:
	MOV AX, -1
L1:
	MOV WORD PTR X, AX
	MOV AX, 4C00h
	INT 21h
PROG ends
	end MAIN

TEST: echo Program Var x Begin x = 0 While x ^<= 9 x = x + 1 EndWhile End .  | cap10-tiny10
	.model small
	.stack
	.code
extrn READ:near, WRITE:near
PROG segment byte public
	assume cs:PROG,ds:PROG,es:PROG,ss:PROG
X:	dw 0
MAIN:
	MOV AX, PROG
	MOV DS, AX
	MOV ES, AX
	MOV AX, 0
	MOV WORD PTR X, AX
L0:
	MOV AX, WORD PTR X
	PUSH AX
	MOV AX, 9
	POP BX
	CMP BX, AX
	JLE L2
	XOR AX, AX
	JMP L3
L2:
	MOV AX, -1
L3:
	JZ L1
	MOV AX, WORD PTR X
	PUSH AX
	MOV AX, 1
	POP BX
	ADD AX, BX
	MOV WORD PTR X, AX
	JMP L0
L1:
	MOV AX, 4C00h
	INT 21h
PROG ends
	end MAIN

TEST: echo Program Var x , y Begin x = 1 If x = 1 y = y - 1 Else y = y + 2 EndIf End .  | cap10-tiny10
	.model small
	.stack
	.code
extrn READ:near, WRITE:near
PROG segment byte public
	assume cs:PROG,ds:PROG,es:PROG,ss:PROG
X:	dw 0
Y:	dw 0
MAIN:
	MOV AX, PROG
	MOV DS, AX
	MOV ES, AX
	MOV AX, 1
	MOV WORD PTR X, AX
	MOV AX, WORD PTR X
	PUSH AX
	MOV AX, 1
	POP BX
	CMP BX, AX
	JE L0
	XOR AX, AX
	JMP L1
L0:
	MOV AX, -1
L1:
	JZ L2
	MOV AX, WORD PTR Y
	PUSH AX
	MOV AX, 1
	POP BX
	SUB AX, BX
	NEG AX
	MOV WORD PTR Y, AX
	JMP L3
L2:
	MOV AX, WORD PTR Y
	PUSH AX
	MOV AX, 2
	POP BX
	ADD AX, BX
	MOV WORD PTR Y, AX
L3:
	MOV AX, 4C00h
	INT 21h
PROG ends
	end MAIN

TEST: echo Program Var alfa, beta Begin alfa = 1 If alfa ^<^> 1 beta = beta - 1 Else beta = beta + 2 EndIf End .  | cap10-tiny10
	.model small
	.stack
	.code
extrn READ:near, WRITE:near
PROG segment byte public
	assume cs:PROG,ds:PROG,es:PROG,ss:PROG
ALFA:	dw 0
BETA:	dw 0
MAIN:
	MOV AX, PROG
	MOV DS, AX
	MOV ES, AX
	MOV AX, 1
	MOV WORD PTR ALFA, AX
	MOV AX, WORD PTR ALFA
	PUSH AX
	MOV AX, 1
	POP BX
	CMP BX, AX
	JNE L0
	XOR AX, AX
	JMP L1
L0:
	MOV AX, -1
L1:
	JZ L2
	MOV AX, WORD PTR BETA
	PUSH AX
	MOV AX, 1
	POP BX
	SUB AX, BX
	NEG AX
	MOV WORD PTR BETA, AX
	JMP L3
L2:
	MOV AX, WORD PTR BETA
	PUSH AX
	MOV AX, 2
	POP BX
	ADD AX, BX
	MOV WORD PTR BETA, AX
L3:
	MOV AX, 4C00h
	INT 21h
PROG ends
	end MAIN

TEST: echo Program Var alfa, beta Begin Read(alfa, beta) If alfa ^>^= 1 beta = beta - 1 Else beta = beta + 2 EndIf Write(alfa, beta) End .   | cap10-tiny10
	.model small
	.stack
	.code
extrn READ:near, WRITE:near
PROG segment byte public
	assume cs:PROG,ds:PROG,es:PROG,ss:PROG
ALFA:	dw 0
BETA:	dw 0
MAIN:
	MOV AX, PROG
	MOV DS, AX
	MOV ES, AX
	CALL READ
	MOV WORD PTR ALFA, AX
	CALL READ
	MOV WORD PTR BETA, AX
	MOV AX, WORD PTR ALFA
	PUSH AX
	MOV AX, 1
	POP BX
	CMP BX, AX
	JGE L0
	XOR AX, AX
	JMP L1
L0:
	MOV AX, -1
L1:
	JZ L2
	MOV AX, WORD PTR BETA
	PUSH AX
	MOV AX, 1
	POP BX
	SUB AX, BX
	NEG AX
	MOV WORD PTR BETA, AX
	JMP L3
L2:
	MOV AX, WORD PTR BETA
	PUSH AX
	MOV AX, 2
	POP BX
	ADD AX, BX
	MOV WORD PTR BETA, AX
L3:
	MOV AX, WORD PTR ALFA
	CALL WRITE
	MOV AX, WORD PTR BETA
	CALL WRITE
	MOV AX, 4C00h
	INT 21h
PROG ends
	end MAIN

TEST: echo a bc def 1 23 456 + - * / = ^>= ^<= .  | cap11-lex
Token: x Value: A
Token: x Value: BC
Token: x Value: DEF
Token: # Value: 1
Token: # Value: 23
Token: # Value: 456
Token: + Value: +
Token: - Value: -
Token: * Value: *
Token: / Value: /
Token: = Value: =
Token: > Value: >
Token: = Value: =
Token: < Value: <
Token: = Value: =
Token: . Value: .

TEST: echo Program Begin End .  | cap11-tiny11
	.model small
	.stack
	.code
extrn READ:near, WRITE:near
PROG segment byte public
	assume cs:PROG,ds:PROG,es:PROG,ss:PROG
MAIN:
	MOV AX, PROG
	MOV DS, AX
	MOV ES, AX
	MOV AX, 4C00h
	INT 21h
PROG ends
	end MAIN

TEST: echo Program Var x Var y Var z Begin End .  | cap11-tiny11
	.model small
	.stack
	.code
extrn READ:near, WRITE:near
PROG segment byte public
	assume cs:PROG,ds:PROG,es:PROG,ss:PROG
X:	dw 0
Y:	dw 0
Z:	dw 0
MAIN:
	MOV AX, PROG
	MOV DS, AX
	MOV ES, AX
	MOV AX, 4C00h
	INT 21h
PROG ends
	end MAIN

TEST: echo Program Var x,Y,z Var M , N Var O Begin End .  | cap11-tiny11
	.model small
	.stack
	.code
extrn READ:near, WRITE:near
PROG segment byte public
	assume cs:PROG,ds:PROG,es:PROG,ss:PROG
X:	dw 0
Y:	dw 0
Z:	dw 0
M:	dw 0
N:	dw 0
O:	dw 0
MAIN:
	MOV AX, PROG
	MOV DS, AX
	MOV ES, AX
	MOV AX, 4C00h
	INT 21h
PROG ends
	end MAIN

TEST: echo Program Var x , y , z Var M , N Var O Begin End .  | cap11-tiny11
	.model small
	.stack
	.code
extrn READ:near, WRITE:near
PROG segment byte public
	assume cs:PROG,ds:PROG,es:PROG,ss:PROG
X:	dw 0
Y:	dw 0
Z:	dw 0
M:	dw 0
N:	dw 0
O:	dw 0
MAIN:
	MOV AX, PROG
	MOV DS, AX
	MOV ES, AX
	MOV AX, 4C00h
	INT 21h
PROG ends
	end MAIN

TEST: echo Program Var x , y , z Var M , N Var O Begin End .  | cap11-tiny11
	.model small
	.stack
	.code
extrn READ:near, WRITE:near
PROG segment byte public
	assume cs:PROG,ds:PROG,es:PROG,ss:PROG
X:	dw 0
Y:	dw 0
Z:	dw 0
M:	dw 0
N:	dw 0
O:	dw 0
MAIN:
	MOV AX, PROG
	MOV DS, AX
	MOV ES, AX
	MOV AX, 4C00h
	INT 21h
PROG ends
	end MAIN

TEST: echo Program Var x , y , z Begin z = x - y + ( - x * y ) / 10 End .  | cap11-tiny11
	.model small
	.stack
	.code
extrn READ:near, WRITE:near
PROG segment byte public
	assume cs:PROG,ds:PROG,es:PROG,ss:PROG
X:	dw 0
Y:	dw 0
Z:	dw 0
MAIN:
	MOV AX, PROG
	MOV DS, AX
	MOV ES, AX
	MOV AX, WORD PTR X
	PUSH AX
	MOV AX, WORD PTR Y
	POP BX
	SUB AX, BX
	NEG AX
	PUSH AX
	XOR AX, AX
	PUSH AX
	MOV AX, WORD PTR X
	PUSH AX
	MOV AX, WORD PTR Y
	POP BX
	IMUL BX
	POP BX
	SUB AX, BX
	NEG AX
	PUSH AX
	MOV AX, 10
	POP BX
	XCHG AX, BX
	CWD
	IDIV BX
	POP BX
	ADD AX, BX
	MOV WORD PTR Z, AX
	MOV AX, 4C00h
	INT 21h
PROG ends
	end MAIN

TEST: echo Program Var x , y , z Begin x = z ^>= y End .  | cap11-tiny11
	.model small
	.stack
	.code
extrn READ:near, WRITE:near
PROG segment byte public
	assume cs:PROG,ds:PROG,es:PROG,ss:PROG
X:	dw 0
Y:	dw 0
Z:	dw 0
MAIN:
	MOV AX, PROG
	MOV DS, AX
	MOV ES, AX
	MOV AX, WORD PTR Z
	PUSH AX
	MOV AX, WORD PTR Y
	POP BX
	CMP BX, AX
	JGE L0
	XOR AX, AX
	JMP L1
L0:
	MOV AX, -1
L1:
	MOV WORD PTR X, AX
	MOV AX, 4C00h
	INT 21h
PROG ends
	end MAIN

TEST: echo Program Var x Begin x = 0 While x ^<= 9 x = x + 1 EndWhile End .  | cap11-tiny11
	.model small
	.stack
	.code
extrn READ:near, WRITE:near
PROG segment byte public
	assume cs:PROG,ds:PROG,es:PROG,ss:PROG
X:	dw 0
MAIN:
	MOV AX, PROG
	MOV DS, AX
	MOV ES, AX
	MOV AX, 0
	MOV WORD PTR X, AX
L0:
	MOV AX, WORD PTR X
	PUSH AX
	MOV AX, 9
	POP BX
	CMP BX, AX
	JLE L2
	XOR AX, AX
	JMP L3
L2:
	MOV AX, -1
L3:
	JZ L1
	MOV AX, WORD PTR X
	PUSH AX
	MOV AX, 1
	POP BX
	ADD AX, BX
	MOV WORD PTR X, AX
	JMP L0
L1:
	MOV AX, 4C00h
	INT 21h
PROG ends
	end MAIN

TEST: echo Program Var x , y Begin x = 1 If x = 1 y = y - 1 Else y = y + 2 EndIf End .  | cap11-tiny11
	.model small
	.stack
	.code
extrn READ:near, WRITE:near
PROG segment byte public
	assume cs:PROG,ds:PROG,es:PROG,ss:PROG
X:	dw 0
Y:	dw 0
MAIN:
	MOV AX, PROG
	MOV DS, AX
	MOV ES, AX
	MOV AX, 1
	MOV WORD PTR X, AX
	MOV AX, WORD PTR X
	PUSH AX
	MOV AX, 1
	POP BX
	CMP BX, AX
	JE L0
	XOR AX, AX
	JMP L1
L0:
	MOV AX, -1
L1:
	JZ L2
	MOV AX, WORD PTR Y
	PUSH AX
	MOV AX, 1
	POP BX
	SUB AX, BX
	NEG AX
	MOV WORD PTR Y, AX
	JMP L3
L2:
	MOV AX, WORD PTR Y
	PUSH AX
	MOV AX, 2
	POP BX
	ADD AX, BX
	MOV WORD PTR Y, AX
L3:
	MOV AX, 4C00h
	INT 21h
PROG ends
	end MAIN

TEST: echo Program Var alfa, beta Begin alfa = 1 If alfa ^<^> 1 beta = beta - 1 Else beta = beta + 2 EndIf End .  | cap11-tiny11
	.model small
	.stack
	.code
extrn READ:near, WRITE:near
PROG segment byte public
	assume cs:PROG,ds:PROG,es:PROG,ss:PROG
ALFA:	dw 0
BETA:	dw 0
MAIN:
	MOV AX, PROG
	MOV DS, AX
	MOV ES, AX
	MOV AX, 1
	MOV WORD PTR ALFA, AX
	MOV AX, WORD PTR ALFA
	PUSH AX
	MOV AX, 1
	POP BX
	CMP BX, AX
	JNE L0
	XOR AX, AX
	JMP L1
L0:
	MOV AX, -1
L1:
	JZ L2
	MOV AX, WORD PTR BETA
	PUSH AX
	MOV AX, 1
	POP BX
	SUB AX, BX
	NEG AX
	MOV WORD PTR BETA, AX
	JMP L3
L2:
	MOV AX, WORD PTR BETA
	PUSH AX
	MOV AX, 2
	POP BX
	ADD AX, BX
	MOV WORD PTR BETA, AX
L3:
	MOV AX, 4C00h
	INT 21h
PROG ends
	end MAIN

TEST: echo Program Var alfa, beta Begin Read(alfa, beta) If alfa ^>^= 1 beta = beta - 1 Else beta = beta + 2 EndIf Write(alfa, beta) End .   | cap11-tiny11
	.model small
	.stack
	.code
extrn READ:near, WRITE:near
PROG segment byte public
	assume cs:PROG,ds:PROG,es:PROG,ss:PROG
ALFA:	dw 0
BETA:	dw 0
MAIN:
	MOV AX, PROG
	MOV DS, AX
	MOV ES, AX
	CALL READ
	MOV WORD PTR ALFA, AX
	CALL READ
	MOV WORD PTR BETA, AX
	MOV AX, WORD PTR ALFA
	PUSH AX
	MOV AX, 1
	POP BX
	CMP BX, AX
	JGE L0
	XOR AX, AX
	JMP L1
L0:
	MOV AX, -1
L1:
	JZ L2
	MOV AX, WORD PTR BETA
	PUSH AX
	MOV AX, 1
	POP BX
	SUB AX, BX
	NEG AX
	MOV WORD PTR BETA, AX
	JMP L3
L2:
	MOV AX, WORD PTR BETA
	PUSH AX
	MOV AX, 2
	POP BX
	ADD AX, BX
	MOV WORD PTR BETA, AX
L3:
	MOV AX, WORD PTR ALFA
	CALL WRITE
	MOV AX, WORD PTR BETA
	CALL WRITE
	MOV AX, 4C00h
	INT 21h
PROG ends
	end MAIN

TEST: echo Program; Var x, y; Begin x = 0; y = 10; While !(x = 10) x = x + 1; y = y - 1; EndWhile; End .  | cap12-tiny12
	.model small
	.stack
	.code
extrn READ:near, WRITE:near
PROG segment byte public
	assume cs:PROG,ds:PROG,es:PROG,ss:PROG
X:	dw 0
Y:	dw 0
MAIN:
	MOV AX, PROG
	MOV DS, AX
	MOV ES, AX
	MOV AX, 0
	MOV WORD PTR X, AX
	MOV AX, 10
	MOV WORD PTR Y, AX
L0:
	MOV AX, WORD PTR X
	PUSH AX
	MOV AX, 10
	POP BX
	CMP BX, AX
	JE L2
	XOR AX, AX
	JMP L3
L2:
	MOV AX, -1
L3:
	NOT AX
	JZ L1
	MOV AX, WORD PTR X
	PUSH AX
	MOV AX, 1
	POP BX
	ADD AX, BX
	MOV WORD PTR X, AX
	MOV AX, WORD PTR Y
	PUSH AX
	MOV AX, 1
	POP BX
	SUB AX, BX
	NEG AX
	MOV WORD PTR Y, AX
	JMP L0
L1:
	MOV AX, 4C00h
	INT 21h
PROG ends
	end MAIN

TEST: echo {x}Program{x};{x}{}Var{x} alfa, beta; Begin{x}   Read(alfa,{x} beta);   If alfa {x}^>= 1{x}     beta {x}= beta - 1  {x{y}z} Else     beta{x} = beta + 2;{ }  EndIf{x};   Write(alfa{x}, beta){ }End{x}  | cap12-tiny13
	.model small
	.stack
	.code
extrn READ:near, WRITE:near
PROG segment byte public
	assume cs:PROG,ds:PROG,es:PROG,ss:PROG
ALFA:	dw 0
BETA:	dw 0
MAIN:
	MOV AX, PROG
	MOV DS, AX
	MOV ES, AX
	CALL READ
	MOV WORD PTR ALFA, AX
	CALL READ
	MOV WORD PTR BETA, AX
	MOV AX, WORD PTR ALFA
	PUSH AX
	MOV AX, 1
	POP BX
	CMP BX, AX
	JGE L0
	XOR AX, AX
	JMP L1
L0:
	MOV AX, -1
L1:
	JZ L2
	MOV AX, WORD PTR BETA
	PUSH AX
	MOV AX, 1
	POP BX
	SUB AX, BX
	NEG AX
	MOV WORD PTR BETA, AX
	JMP L3
L2:
	MOV AX, WORD PTR BETA
	PUSH AX
	MOV AX, 2
	POP BX
	ADD AX, BX
	MOV WORD PTR BETA, AX
L3:
	MOV AX, WORD PTR ALFA
	CALL WRITE
	MOV AX, WORD PTR BETA
	CALL WRITE
	MOV AX, 4C00h
	INT 21h
PROG ends
	end MAIN

TEST: echo va vb vc b a=b c=b e.  | cap13-base
A	dw 0
B	dw 0
C	dw 0
	MOV AX, WORD PTR B
	MOV WORD PTR A, AX
	MOV AX, WORD PTR B
	MOV WORD PTR C, AX

TEST: echo va px(m) b a=m e vb py(m,n) b b=m n=a x(b) e vc pz(m,n,o) b n=b c=m y(b,n) e Pp b x(a) a=b y(a,b) c=b z(a,b,c) e.  | cap13-byval
	.model small
	.stack
	.code
PROG segment byte public
	assume cs:PROG,ds:PROG,es:PROG,ss:PROG
A	dw 0
X:
	PUSH BP
	MOV BP, SP
	MOV AX, WORD PTR [BP+4]
	MOV WORD PTR A, AX
	POP BP
	RET
B	dw 0
Y:
	PUSH BP
	MOV BP, SP
	MOV AX, WORD PTR [BP+6]
	MOV WORD PTR B, AX
	MOV AX, WORD PTR A
	MOV WORD PTR [BP+4], AX
	MOV AX, WORD PTR B
	PUSH AX
	CALL X
	ADD SP, 2
	POP BP
	RET
C	dw 0
Z:
	PUSH BP
	MOV BP, SP
	MOV AX, WORD PTR B
	MOV WORD PTR [BP+6], AX
	MOV AX, WORD PTR [BP+8]
	MOV WORD PTR C, AX
	MOV AX, WORD PTR B
	PUSH AX
	MOV AX, WORD PTR [BP+6]
	PUSH AX
	CALL Y
	ADD SP, 4
	POP BP
	RET
MAIN:
	MOV AX, PROG
	MOV DS, AX
	MOV ES, AX
	MOV AX, WORD PTR A
	PUSH AX
	CALL X
	ADD SP, 2
	MOV AX, WORD PTR B
	MOV WORD PTR A, AX
	MOV AX, WORD PTR A
	PUSH AX
	MOV AX, WORD PTR B
	PUSH AX
	CALL Y
	ADD SP, 4
	MOV AX, WORD PTR B
	MOV WORD PTR C, AX
	MOV AX, WORD PTR A
	PUSH AX
	MOV AX, WORD PTR B
	PUSH AX
	MOV AX, WORD PTR C
	PUSH AX
	CALL Z
	ADD SP, 6
	MOV AX, 4C00h
	INT 21h
PROG ends
	end MAIN

TEST: echo va px(m) b a=m e vb py(m,n) b b=m n=a x(b) e vc pz(m,n,o) b n=b c=m y(b,n) e Pp b x(a) a=b y(a,b) c=b z(a,b,c) e.  | cap13-byref
	.model small
	.stack
	.code
PROG segment byte public
	assume cs:PROG,ds:PROG,es:PROG,ss:PROG
A	dw 0
X:
	PUSH BP
	MOV BP, SP
	MOV BX, WORD PTR [BP+4]
	MOV AX, WORD PTR [BX]
	MOV WORD PTR A, AX
	POP BP
	RET
B	dw 0
Y:
	PUSH BP
	MOV BP, SP
	MOV BX, WORD PTR [BP+6]
	MOV AX, WORD PTR [BX]
	MOV WORD PTR B, AX
	MOV AX, WORD PTR A
	MOV BX, WORD PTR [BP+4]
	MOV WORD PTR [BX], AX
	MOV AX, OFFSET B
	PUSH AX
	CALL X
	ADD SP, 2
	POP BP
	RET
C	dw 0
Z:
	PUSH BP
	MOV BP, SP
	MOV AX, WORD PTR B
	MOV BX, WORD PTR [BP+6]
	MOV WORD PTR [BX], AX
	MOV BX, WORD PTR [BP+8]
	MOV AX, WORD PTR [BX]
	MOV WORD PTR C, AX
	MOV AX, OFFSET B
	PUSH AX
	MOV AX, WORD PTR [BP+6]
	PUSH AX
	CALL Y
	ADD SP, 4
	POP BP
	RET
MAIN:
	MOV AX, PROG
	MOV DS, AX
	MOV ES, AX
	MOV AX, OFFSET A
	PUSH AX
	CALL X
	ADD SP, 2
	MOV AX, WORD PTR B
	MOV WORD PTR A, AX
	MOV AX, OFFSET A
	PUSH AX
	MOV AX, OFFSET B
	PUSH AX
	CALL Y
	ADD SP, 4
	MOV AX, WORD PTR B
	MOV WORD PTR C, AX
	MOV AX, OFFSET A
	PUSH AX
	MOV AX, OFFSET B
	PUSH AX
	MOV AX, OFFSET C
	PUSH AX
	CALL Z
	ADD SP, 6
	MOV AX, 4C00h
	INT 21h
PROG ends
	end MAIN

TEST: echo va px(m) b a=m e vb py(m,n) vi b b=m n=a i=b x(i) e vc pz(m,n,o) vi vj b n=b c=m y(b,n) i=j e Pp b x(a) a=b y(a,b) c=b z(a,b,c) e.  | cap13-locals
	.model small
	.stack
	.code
PROG segment byte public
	assume cs:PROG,ds:PROG,es:PROG,ss:PROG
A	dw 0
X:
	PUSH BP
	MOV BP, SP
	SUB SP, 0
	MOV AX, WORD PTR [BP+4]
	MOV WORD PTR A, AX
	MOV SP, BP
	POP BP
	RET
B	dw 0
Y:
	PUSH BP
	MOV BP, SP
	SUB SP, 2
	MOV AX, WORD PTR [BP+6]
	MOV WORD PTR B, AX
	MOV AX, WORD PTR A
	MOV WORD PTR [BP+4], AX
	MOV AX, WORD PTR B
	MOV WORD PTR [BP-2], AX
	MOV AX, WORD PTR [BP-2]
	PUSH AX
	CALL X
	ADD SP, 2
	MOV SP, BP
	POP BP
	RET
C	dw 0
Z:
	PUSH BP
	MOV BP, SP
	SUB SP, 4
	MOV AX, WORD PTR B
	MOV WORD PTR [BP+6], AX
	MOV AX, WORD PTR [BP+8]
	MOV WORD PTR C, AX
	MOV AX, WORD PTR B
	PUSH AX
	MOV AX, WORD PTR [BP+6]
	PUSH AX
	CALL Y
	ADD SP, 4
	MOV AX, WORD PTR [BP-4]
	MOV WORD PTR [BP-2], AX
	MOV SP, BP
	POP BP
	RET
MAIN:
	MOV AX, PROG
	MOV DS, AX
	MOV ES, AX
	MOV AX, WORD PTR A
	PUSH AX
	CALL X
	ADD SP, 2
	MOV AX, WORD PTR B
	MOV WORD PTR A, AX
	MOV AX, WORD PTR A
	PUSH AX
	MOV AX, WORD PTR B
	PUSH AX
	CALL Y
	ADD SP, 4
	MOV AX, WORD PTR B
	MOV WORD PTR C, AX
	MOV AX, WORD PTR A
	PUSH AX
	MOV AX, WORD PTR B
	PUSH AX
	MOV AX, WORD PTR C
	PUSH AX
	CALL Z
	ADD SP, 6
	MOV AX, 4C00h
	INT 21h
PROG ends
	end MAIN

TEST: cap14-base  0<nul 
Symbol table dump:
A = ?
B = ?
C = ?
D = ?
E = ?
F = ?
G = ?
H = ?
I = ?
J = ?
K = ?
L = ?
M = ?
N = ?
O = ?
P = ?
Q = ?
R = ?
S = ?
T = ?
U = ?
V = ?
W = ?
X = ?
Y = ?
Z = ?

TEST: echo ba wb lc B .   | cap14-types
A db 0
B dw 0
C dd 0
Symbol table dump:
A = b
B = w
C = l

TEST: echo ba wb lc B a=a a=b a=c b=a b=b b=c c=a c=b c=c .   | cap14-types
A db 0
B dw 0
C dd 0
	MOV AL, BYTE PTR A
	MOV BYTE PTR A, AL
	MOV AX, WORD PTR B
	MOV BYTE PTR A, AL
	MOV DX, WORD PTR [C+2]
	MOV AX, WORD PTR [C]
	MOV BYTE PTR A, AL
	MOV AL, BYTE PTR A
	CBW
	MOV WORD PTR B, AX
	MOV AX, WORD PTR B
	MOV WORD PTR B, AX
	MOV DX, WORD PTR [C+2]
	MOV AX, WORD PTR [C]
	MOV WORD PTR B, AX
	MOV AL, BYTE PTR A
	CBW
	CWD
	MOV WORD PTR [C+2], DX
	MOV WORD PTR [C], AX
	MOV AX, WORD PTR B
	CWD
	MOV WORD PTR [C+2], DX
	MOV WORD PTR [C], AX
	MOV DX, WORD PTR [C+2]
	MOV AX, WORD PTR [C]
	MOV WORD PTR [C+2], DX
	MOV WORD PTR [C], AX
Symbol table dump:
A = b
B = w
C = l

TEST: echo ba wb lc B a=42 b=1999 c=999999 a=888888 b=77 c=666 .   | cap14-types
A db 0
B dw 0
C dd 0
	MOV AL, 42
	MOV BYTE PTR A, AL
	MOV AX, 1999
	MOV WORD PTR B, AX
	MOV DX, 15
	MOV AX, 16959
	MOV WORD PTR [C+2], DX
	MOV WORD PTR [C], AX
	MOV DX, 13
	MOV AX, 36920
	MOV BYTE PTR A, AL
	MOV AL, 77
	CBW
	MOV WORD PTR B, AX
	MOV AX, 666
	CWD
	MOV WORD PTR [C+2], DX
	MOV WORD PTR [C], AX
Symbol table dump:
A = b
B = w
C = l

TEST: echo ba wb lc B a=a+a a=a-a b=b+b b=b-b c=c+c c=c-c .   | cap14-types
A db 0
B dw 0
C dd 0
	MOV AL, BYTE PTR A
	CBW
	PUSH AX
	MOV AL, BYTE PTR A
	POP BX
	ADD AL, BL
	MOV BYTE PTR A, AL
	MOV AL, BYTE PTR A
	CBW
	PUSH AX
	MOV AL, BYTE PTR A
	POP BX
	XCHG AL, BL
	SUB AL, BL
	MOV BYTE PTR A, AL
	MOV AX, WORD PTR B
	PUSH AX
	MOV AX, WORD PTR B
	POP BX
	ADD AX, BX
	MOV WORD PTR B, AX
	MOV AX, WORD PTR B
	PUSH AX
	MOV AX, WORD PTR B
	POP BX
	XCHG AX, BX
	SUB AX, BX
	MOV WORD PTR B, AX
	MOV DX, WORD PTR [C+2]
	MOV AX, WORD PTR [C]
	PUSH DX
	PUSH AX
	MOV DX, WORD PTR [C+2]
	MOV AX, WORD PTR [C]
	POP BX
	POP CX
	ADD AX, BX
	ADC DX, CX
	MOV WORD PTR [C+2], DX
	MOV WORD PTR [C], AX
	MOV DX, WORD PTR [C+2]
	MOV AX, WORD PTR [C]
	PUSH DX
	PUSH AX
	MOV DX, WORD PTR [C+2]
	MOV AX, WORD PTR [C]
	POP BX
	POP CX
	XCHG AX, BX
	XCHG DX, CX
	SUB AX, BX
	SBB DX, CX
	MOV WORD PTR [C+2], DX
	MOV WORD PTR [C], AX
Symbol table dump:
A = b
B = w
C = l

TEST: echo ba wb lc B a=b+c a=c+b b=a+c b=c+b c=a+b c=b+a .   | cap14-types
A db 0
B dw 0
C dd 0
	MOV AX, WORD PTR B
	PUSH AX
	MOV DX, WORD PTR [C+2]
	MOV AX, WORD PTR [C]
	POP BX
	XCHG AX, BX
	XCHG DX, CX
	CWD
	ADD AX, BX
	ADC DX, CX
	MOV BYTE PTR A, AL
	MOV DX, WORD PTR [C+2]
	MOV AX, WORD PTR [C]
	PUSH DX
	PUSH AX
	MOV AX, WORD PTR B
	POP BX
	POP CX
	CWD
	ADD AX, BX
	ADC DX, CX
	MOV BYTE PTR A, AL
	MOV AL, BYTE PTR A
	CBW
	PUSH AX
	MOV DX, WORD PTR [C+2]
	MOV AX, WORD PTR [C]
	POP BX
	XCHG AX, BX
	XCHG DX, CX
	CBW
	CWD
	ADD AX, BX
	ADC DX, CX
	MOV WORD PTR B, AX
	MOV DX, WORD PTR [C+2]
	MOV AX, WORD PTR [C]
	PUSH DX
	PUSH AX
	MOV AX, WORD PTR B
	POP BX
	POP CX
	CWD
	ADD AX, BX
	ADC DX, CX
	MOV WORD PTR B, AX
	MOV AL, BYTE PTR A
	CBW
	PUSH AX
	MOV AX, WORD PTR B
	POP BX
	XCHG AX, BX
	CBW
	ADD AX, BX
	CWD
	MOV WORD PTR [C+2], DX
	MOV WORD PTR [C], AX
	MOV AX, WORD PTR B
	PUSH AX
	MOV AL, BYTE PTR A
	POP BX
	CBW
	ADD AX, BX
	CWD
	MOV WORD PTR [C+2], DX
	MOV WORD PTR [C], AX
Symbol table dump:
A = b
B = w
C = l

TEST: echo ba wb lc B a=b-c a=c-b b=a-c b=c-b c=a-b c=b-a .   | cap14-types
A db 0
B dw 0
C dd 0
	MOV AX, WORD PTR B
	PUSH AX
	MOV DX, WORD PTR [C+2]
	MOV AX, WORD PTR [C]
	POP BX
	XCHG AX, BX
	XCHG DX, CX
	CWD
	SUB AX, BX
	SBB DX, CX
	MOV BYTE PTR A, AL
	MOV DX, WORD PTR [C+2]
	MOV AX, WORD PTR [C]
	PUSH DX
	PUSH AX
	MOV AX, WORD PTR B
	POP BX
	POP CX
	CWD
	XCHG AX, BX
	XCHG DX, CX
	SUB AX, BX
	SBB DX, CX
	MOV BYTE PTR A, AL
	MOV AL, BYTE PTR A
	CBW
	PUSH AX
	MOV DX, WORD PTR [C+2]
	MOV AX, WORD PTR [C]
	POP BX
	XCHG AX, BX
	XCHG DX, CX
	CBW
	CWD
	SUB AX, BX
	SBB DX, CX
	MOV WORD PTR B, AX
	MOV DX, WORD PTR [C+2]
	MOV AX, WORD PTR [C]
	PUSH DX
	PUSH AX
	MOV AX, WORD PTR B
	POP BX
	POP CX
	CWD
	XCHG AX, BX
	XCHG DX, CX
	SUB AX, BX
	SBB DX, CX
	MOV WORD PTR B, AX
	MOV AL, BYTE PTR A
	CBW
	PUSH AX
	MOV AX, WORD PTR B
	POP BX
	XCHG AX, BX
	CBW
	SUB AX, BX
	CWD
	MOV WORD PTR [C+2], DX
	MOV WORD PTR [C], AX
	MOV AX, WORD PTR B
	PUSH AX
	MOV AL, BYTE PTR A
	POP BX
	CBW
	XCHG AX, BX
	SUB AX, BX
	CWD
	MOV WORD PTR [C+2], DX
	MOV WORD PTR [C], AX
Symbol table dump:
A = b
B = w
C = l

TEST: echo ba wb lc B a=a*a a=a/a b=b*b b=b/b c=c*c c=c/c .   | cap14-types
A db 0
B dw 0
C dd 0
	MOV AL, BYTE PTR A
	CBW
	PUSH AX
	MOV AL, BYTE PTR A
	POP BX
	IMUL BL
	MOV BYTE PTR A, AL
	MOV AL, BYTE PTR A
	CBW
	PUSH AX
	MOV AL, BYTE PTR A
	POP BX
	XCHG AL, BL
	CBW
	IDIV BL
	MOV BYTE PTR A, AL
	MOV AX, WORD PTR B
	PUSH AX
	MOV AX, WORD PTR B
	POP BX
	IMUL BX
	MOV WORD PTR B, AX
	MOV AX, WORD PTR B
	PUSH AX
	MOV AX, WORD PTR B
	POP BX
	XCHG AX, BX
	CWD
	IDIV BX
	MOV WORD PTR B, AX
	MOV DX, WORD PTR [C+2]
	MOV AX, WORD PTR [C]
	PUSH DX
	PUSH AX
	MOV DX, WORD PTR [C+2]
	MOV AX, WORD PTR [C]
	POP BX
	POP CX
	CALL MUL32
	MOV WORD PTR [C+2], DX
	MOV WORD PTR [C], AX
	MOV DX, WORD PTR [C+2]
	MOV AX, WORD PTR [C]
	PUSH DX
	PUSH AX
	MOV DX, WORD PTR [C+2]
	MOV AX, WORD PTR [C]
	POP BX
	POP CX
	XCHG AX, BX
	XCHG DX, CX
	CALL DIV32
	MOV WORD PTR [C+2], DX
	MOV WORD PTR [C], AX
Symbol table dump:
A = b
B = w
C = l

TEST: echo ba wb lc B a=b*c a=c*b b=a*c b=c*b c=a*b c=b*a .   | cap14-types
A db 0
B dw 0
C dd 0
	MOV AX, WORD PTR B
	PUSH AX
	MOV DX, WORD PTR [C+2]
	MOV AX, WORD PTR [C]
	POP BX
	XCHG AX, BX
	XCHG DX, CX
	CWD
	CALL MUL32
	MOV BYTE PTR A, AL
	MOV DX, WORD PTR [C+2]
	MOV AX, WORD PTR [C]
	PUSH DX
	PUSH AX
	MOV AX, WORD PTR B
	POP BX
	POP CX
	CWD
	CALL MUL32
	MOV BYTE PTR A, AL
	MOV AL, BYTE PTR A
	CBW
	PUSH AX
	MOV DX, WORD PTR [C+2]
	MOV AX, WORD PTR [C]
	POP BX
	XCHG AX, BX
	XCHG DX, CX
	CBW
	CWD
	CALL MUL32
	MOV WORD PTR B, AX
	MOV DX, WORD PTR [C+2]
	MOV AX, WORD PTR [C]
	PUSH DX
	PUSH AX
	MOV AX, WORD PTR B
	POP BX
	POP CX
	CWD
	CALL MUL32
	MOV WORD PTR B, AX
	MOV AL, BYTE PTR A
	CBW
	PUSH AX
	MOV AX, WORD PTR B
	POP BX
	XCHG AX, BX
	CBW
	IMUL BX
	MOV WORD PTR [C+2], DX
	MOV WORD PTR [C], AX
	MOV AX, WORD PTR B
	PUSH AX
	MOV AL, BYTE PTR A
	POP BX
	CBW
	IMUL BX
	MOV WORD PTR [C+2], DX
	MOV WORD PTR [C], AX
Symbol table dump:
A = b
B = w
C = l

TEST: echo ba wb lc B a=b/c a=c/b b=a/c b=c/b c=a/b c=b/a .   | cap14-types
A db 0
B dw 0
C dd 0
	MOV AX, WORD PTR B
	PUSH AX
	MOV DX, WORD PTR [C+2]
	MOV AX, WORD PTR [C]
	POP BX
	XCHG AX, BX
	XCHG DX, CX
	CWD
	CALL DIV32
	MOV BYTE PTR A, AL
	MOV DX, WORD PTR [C+2]
	MOV AX, WORD PTR [C]
	PUSH DX
	PUSH AX
	MOV AX, WORD PTR B
	POP BX
	POP CX
	CWD
	XCHG AX, BX
	XCHG DX, CX
	CALL DIV32
	MOV BYTE PTR A, AL
	MOV AL, BYTE PTR A
	CBW
	PUSH AX
	MOV DX, WORD PTR [C+2]
	MOV AX, WORD PTR [C]
	POP BX
	XCHG AX, BX
	XCHG DX, CX
	CBW
	CWD
	CALL DIV32
	CBW
	MOV WORD PTR B, AX
	MOV DX, WORD PTR [C+2]
	MOV AX, WORD PTR [C]
	PUSH DX
	PUSH AX
	MOV AX, WORD PTR B
	POP BX
	POP CX
	CWD
	XCHG AX, BX
	XCHG DX, CX
	CALL DIV32
	MOV WORD PTR B, AX
	MOV AL, BYTE PTR A
	CBW
	PUSH AX
	MOV AX, WORD PTR B
	POP BX
	XCHG AX, BX
	CBW
	CWD
	IDIV BX
	CBW
	CWD
	MOV WORD PTR [C+2], DX
	MOV WORD PTR [C], AX
	MOV AX, WORD PTR B
	PUSH AX
	MOV AL, BYTE PTR A
	POP BX
	XCHG AX, BX
	IDIV BL
	CWD
	MOV WORD PTR [C+2], DX
	MOV WORD PTR [C], AX
Symbol table dump:
A = b
B = w
C = l

TEST: echo ba wb lc ld B d=(b*b)-(4*a*c) .   | cap14-types
A db 0
B dw 0
C dd 0
D dd 0
	MOV AX, WORD PTR B
	PUSH AX
	MOV AX, WORD PTR B
	POP BX
	IMUL BX
	PUSH DX
	PUSH AX
	MOV AL, 4
	CBW
	PUSH AX
	MOV AL, BYTE PTR A
	POP BX
	IMUL BL
	PUSH AX
	MOV DX, WORD PTR [C+2]
	MOV AX, WORD PTR [C]
	POP BX
	XCHG AX, BX
	XCHG DX, CX
	CWD
	CALL MUL32
	POP BX
	POP CX
	XCHG AX, BX
	XCHG DX, CX
	SUB AX, BX
	SBB DX, CX
	MOV WORD PTR [D+2], DX
	MOV WORD PTR [D], AX
Symbol table dump:
A = b
B = w
C = l
D = l

TEST: echo 1   | cap15-single
	MOV AX, 1

TEST: echo x   | cap15-single
	MOV AX, X

TEST: echo 12345   | cap15-multi
	MOV AX, 12345

TEST: echo alfa   | cap15-multi
	MOV AX, ALFA

TEST: echo a=-1   | cap16-single
	MOV AX, 1
	NEG AX
	MOV A, AX

TEST: echo a=-x   | cap16-single
	MOV AX, X
	NEG AX
	MOV A, AX

TEST: echo d=b*b-4*a*c/2   | cap16-single
	MOV AX, B
	PUSH AX
	MOV AX, B
	POP BX
	IMUL BX
	PUSH AX
	MOV AX, 4
	PUSH AX
	MOV AX, A
	POP BX
	IMUL BX
	PUSH AX
	MOV AX, C
	POP BX
	IMUL BX
	PUSH AX
	MOV AX, 2
	POP BX
	XCHG AX, BX
	CWD
	IDIV BX
	POP BX
	SUB AX, BX
	NEG AX
	MOV D, AX

TEST: echo s=o^|n~s   | cap16-single
	MOV AX, O
	PUSH AX
	MOV AX, N
	POP BX
	OR AX, BX
	PUSH AX
	MOV AX, S
	POP BX
	XOR AX, BX
	MOV S, AX

TEST: echo b=(a^|b)^&(c~d)   | cap16-single
	MOV AX, A
	PUSH AX
	MOV AX, B
	POP BX
	OR AX, BX
	PUSH AX
	MOV AX, C
	PUSH AX
	MOV AX, D
	POP BX
	XOR AX, BX
	POP BX
	AND AX, BX
	MOV B, AX

TEST: echo x=a^&!b^|!a^&b   | cap16-single
	MOV AX, A
	PUSH AX
	MOV AX, B
	NOT AX
	POP BX
	AND AX, BX
	PUSH AX
	MOV AX, A
	NOT AX
	PUSH AX
	MOV AX, B
	POP BX
	AND AX, BX
	POP BX
	OR AX, BX
	MOV X, AX

TEST: echo a=-123   | cap16-multi
	MOV AX, 123
	NEG AX
	MOV A, AX

TEST: echo a=-alfa   | cap16-multi
	MOV AX, ALFA
	NEG AX
	MOV A, AX

TEST: echo delta=beta*beta-412*alfa*cappa/2121   | cap16-multi
	MOV AX, BETA
	PUSH AX
	MOV AX, BETA
	POP BX
	IMUL BX
	PUSH AX
	MOV AX, 412
	PUSH AX
	MOV AX, ALFA
	POP BX
	IMUL BX
	PUSH AX
	MOV AX, CAPPA
	POP BX
	IMUL BX
	PUSH AX
	MOV AX, 2121
	POP BX
	XCHG AX, BX
	CWD
	IDIV BX
	POP BX
	SUB AX, BX
	NEG AX
	MOV DELTA, AX

TEST: echo ser=ou^|nao~ser   | cap16-multi
	MOV AX, OU
	PUSH AX
	MOV AX, NAO
	POP BX
	OR AX, BX
	PUSH AX
	MOV AX, SER
	POP BX
	XOR AX, BX
	MOV SER, AX

TEST: echo bool=(a^|b)^&(c~d)   | cap16-multi
	MOV AX, A
	PUSH AX
	MOV AX, B
	POP BX
	OR AX, BX
	PUSH AX
	MOV AX, C
	PUSH AX
	MOV AX, D
	POP BX
	XOR AX, BX
	POP BX
	AND AX, BX
	MOV BOOL, AX

TEST: echo myxor=a^&!b^|!a^&b   | cap16-multi
	MOV AX, A
	PUSH AX
	MOV AX, B
	NOT AX
	POP BX
	AND AX, BX
	PUSH AX
	MOV AX, A
	NOT AX
	PUSH AX
	MOV AX, B
	POP BX
	AND AX, BX
	POP BX
	OR AX, BX
	MOV MYXOR, AX

=================
Testes de Falha
=================


TEST: cap02-expr  0<nul 
Error: Integer expected!

TEST: echo x  | cap02-expr
Error: Integer expected!

TEST: echo 1+  | cap02-expr
	MOV AX, 1
	PUSH AX
Error: Integer expected!

TEST: echo *1  | cap02-expr
Error: Integer expected!

TEST: echo 1+2 3+4  | cap03-single
Error: Name expected!

TEST: echo x=f(  | cap03-single
Error: ')' expected!

TEST: cap03-multi  0<nul 
Error: Name expected!

TEST: cap04-interp  0<nul 
Error: Name expected!

TEST: cap05-control  0<nul 
Error: Name expected!

TEST: cap06-bool1  0<nul 
Error: Integer expected!

TEST: echo a*-b  | cap06-bool1
	MOV AX, [A]
	PUSH AX
Error: Integer expected!

TEST: echo a--b  | cap06-bool1
	MOV AX, [A]
	PUSH AX
	MOV AX, [B]
	NEG AX
	POP BX
	SUB AX, BX
	NEG AX

TEST: cap06-bool2  0<nul 
Error: Name expected!

TEST: cap07-lex-subset  0<nul 
Error: Name expected!

TEST: cap07-subset  0<nul 
Error: Name expected!

TEST: cap09-top-pascal  0<nul 
Error: 'p' expected!

TEST: echo .  | cap10-tiny01
Error: 'p' expected!

TEST: echo p  | cap10-tiny01
	.model small
	.stack
	.code
PROG segment byte public
	assume cs:PROG,ds:PROG,es:PROG,ss:PROG
Error: Unrecognized keyword.
Error: BEGIN expected!

TEST: echo pb  | cap10-tiny01
	.model small
	.stack
	.code
PROG segment byte public
	assume cs:PROG,ds:PROG,es:PROG,ss:PROG
MAIN:
	MOV AX, PROG
	MOV DS, AX
	MOV ES, AX
Error: Name expected!

TEST: echo pbe  | cap10-tiny01
	.model small
	.stack
	.code
PROG segment byte public
	assume cs:PROG,ds:PROG,es:PROG,ss:PROG
MAIN:
	MOV AX, PROG
	MOV DS, AX
	MOV ES, AX
	MOV AX, 4C00h
	INT 21h
PROG ends
	end MAIN
Error: '.' expected!

TEST: echo pe.  | cap10-tiny01
	.model small
	.stack
	.code
PROG segment byte public
	assume cs:PROG,ds:PROG,es:PROG,ss:PROG
Error: Unrecognized keyword.
Error: BEGIN expected!

TEST: echo pvavavabe.  | cap10-tiny01
	.model small
	.stack
	.code
PROG segment byte public
	assume cs:PROG,ds:PROG,es:PROG,ss:PROG
A:	dw 0
Error: Duplicate variable name: A

TEST: echo ?   | cap15-single
Error: Unrecognized character: '?'

TEST: echo ?   | cap15-multi
Error: Unrecognized character: '?'

TEST: echo 999999   | cap15-multi
Error: Integer too large.

TEST: echo xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx   | cap15-multi
Error: Identifier too long.
